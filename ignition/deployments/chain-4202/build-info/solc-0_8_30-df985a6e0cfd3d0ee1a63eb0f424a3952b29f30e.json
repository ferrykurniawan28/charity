{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_30-df985a6e0cfd3d0ee1a63eb0f424a3952b29f30e",
  "solcVersion": "0.8.30",
  "solcLongVersion": "0.8.30+commit.73712a01",
  "userSourceNameMap": {
    "contracts/charity.sol": "project/contracts/charity.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "prague",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/charity.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.30;\r\n\r\nimport \"./mockIDRX.sol\";\r\n\r\n/**\r\n * @title CharityPlatform\r\n * @dev Transparent charity platform with ERC-20 token donations\r\n */\r\ncontract CharityPlatform {\r\n    // ============ STATE VARIABLES ============\r\n    IDRXToken public token;\r\n    address public owner;\r\n    uint256 public campaignCounter;\r\n    uint256 public totalDonations;\r\n    \r\n    // ============ STRUCTS ============\r\n    struct Campaign {\r\n        uint256 id;\r\n        address creator;\r\n        string title;\r\n        string description;\r\n        string imageHash; // IPFS hash for transparency\r\n        uint256 targetAmount;\r\n        uint256 raisedAmount;\r\n        address beneficiary;\r\n        uint256 startTime;\r\n        uint256 endTime;\r\n        bool isActive;\r\n        bool fundsReleased;\r\n        uint256 donorCount;\r\n    }\r\n    \r\n    struct Donation {\r\n        address donor;\r\n        uint256 amount;\r\n        uint256 timestamp;\r\n        string message;\r\n    }\r\n    \r\n    // ============ MAPPINGS ============\r\n    mapping(uint256 => Campaign) public campaigns;\r\n    mapping(uint256 => Donation[]) public campaignDonations;\r\n    mapping(uint256 => mapping(address => uint256)) public donorContributions;\r\n    mapping(uint256 => address[]) public campaignDonors;\r\n    \r\n    // ============ EVENTS ============\r\n    event CampaignCreated(\r\n        uint256 indexed campaignId,\r\n        address indexed creator,\r\n        string title,\r\n        uint256 targetAmount,\r\n        uint256 endTime\r\n    );\r\n    \r\n    event DonationReceived(\r\n        uint256 indexed campaignId,\r\n        address indexed donor,\r\n        uint256 amount,\r\n        string message\r\n    );\r\n    \r\n    event FundsReleased(\r\n        uint256 indexed campaignId,\r\n        address indexed beneficiary,\r\n        uint256 amount\r\n    );\r\n    \r\n    event CampaignStatusChanged(\r\n        uint256 indexed campaignId, \r\n        bool isActive\r\n    );\r\n    \r\n    event CampaignExtended(\r\n        uint256 indexed campaignId,\r\n        uint256 newEndTime\r\n    );\r\n\r\n    // ============ MODIFIERS ============\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Only owner can call this function\");\r\n        _;\r\n    }\r\n    \r\n    modifier onlyCampaignCreator(uint256 _campaignId) {\r\n        require(campaigns[_campaignId].creator == msg.sender, \"Not campaign creator\");\r\n        _;\r\n    }\r\n    \r\n    modifier campaignExists(uint256 _campaignId) {\r\n        require(_campaignId > 0 && _campaignId <= campaignCounter, \"Campaign does not exist\");\r\n        _;\r\n    }\r\n    \r\n    modifier campaignActive(uint256 _campaignId) {\r\n        require(campaigns[_campaignId].isActive, \"Campaign not active\");\r\n        require(block.timestamp <= campaigns[_campaignId].endTime, \"Campaign has ended\");\r\n        _;\r\n    }\r\n\r\n    // ============ CONSTRUCTOR ============\r\n    constructor(address _tokenAddress) {\r\n        owner = msg.sender;\r\n        token = IDRXToken(_tokenAddress);\r\n        campaignCounter = 0;\r\n        totalDonations = 0;\r\n    }\r\n\r\n    // ============ EXTERNAL FUNCTIONS ============\r\n\r\n    /**\r\n     * @dev Create a new charity campaign\r\n     */\r\n    function createCampaign(\r\n        string memory _title,\r\n        string memory _description,\r\n        string memory _imageHash,\r\n        uint256 _targetAmount,\r\n        address _beneficiary,\r\n        uint256 _durationInDays\r\n    ) external returns (uint256) {\r\n        require(bytes(_title).length > 0, \"Title cannot be empty\");\r\n        require(bytes(_description).length > 0, \"Description cannot be empty\");\r\n        require(_targetAmount > 0, \"Target amount must be positive\");\r\n        require(_beneficiary != address(0), \"Invalid beneficiary address\");\r\n        require(_durationInDays > 0 && _durationInDays <= 365, \"Duration must be between 1-365 days\");\r\n\r\n        campaignCounter++;\r\n        uint256 endTime = block.timestamp + (_durationInDays * 1 days);\r\n\r\n        campaigns[campaignCounter] = Campaign({\r\n            id: campaignCounter,\r\n            creator: msg.sender,\r\n            title: _title,\r\n            description: _description,\r\n            imageHash: _imageHash,\r\n            targetAmount: _targetAmount,\r\n            raisedAmount: 0,\r\n            beneficiary: _beneficiary,\r\n            startTime: block.timestamp,\r\n            endTime: endTime,\r\n            isActive: true,\r\n            fundsReleased: false,\r\n            donorCount: 0\r\n        });\r\n\r\n        emit CampaignCreated(campaignCounter, msg.sender, _title, _targetAmount, endTime);\r\n        return campaignCounter;\r\n    }\r\n\r\n    /**\r\n     * @dev Donate to a campaign using IDRX tokens\r\n     */\r\n    function donate(\r\n        uint256 _campaignId,\r\n        uint256 _amount,\r\n        string memory _message\r\n    ) external campaignExists(_campaignId) campaignActive(_campaignId) {\r\n        Campaign storage campaign = campaigns[_campaignId];\r\n        \r\n        require(_amount > 0, \"Donation amount must be positive\");\r\n        require(token.balanceOf(msg.sender) >= _amount, \"Insufficient token balance\");\r\n        require(token.allowance(msg.sender, address(this)) >= _amount, \"Insufficient allowance\");\r\n\r\n        // Transfer tokens from donor to this contract\r\n        require(\r\n            token.transferFrom(msg.sender, address(this), _amount),\r\n            \"Token transfer failed\"\r\n        );\r\n\r\n        // Update campaign stats\r\n        campaign.raisedAmount += _amount;\r\n        totalDonations += _amount;\r\n\r\n        // Record donation if it's the first donation from this address\r\n        if (donorContributions[_campaignId][msg.sender] == 0) {\r\n            campaign.donorCount++;\r\n            campaignDonors[_campaignId].push(msg.sender);\r\n        }\r\n        \r\n        donorContributions[_campaignId][msg.sender] += _amount;\r\n\r\n        // Record donation history\r\n        campaignDonations[_campaignId].push(Donation({\r\n            donor: msg.sender,\r\n            amount: _amount,\r\n            timestamp: block.timestamp,\r\n            message: _message\r\n        }));\r\n\r\n        emit DonationReceived(_campaignId, msg.sender, _amount, _message);\r\n    }\r\n\r\n    /**\r\n     * @dev Release funds to beneficiary (creator or owner can call)\r\n     */\r\n    function releaseFunds(uint256 _campaignId) \r\n        external \r\n        campaignExists(_campaignId) \r\n    {\r\n        Campaign storage campaign = campaigns[_campaignId];\r\n        \r\n        require(\r\n            msg.sender == campaign.creator || msg.sender == owner,\r\n            \"Not authorized to release funds\"\r\n        );\r\n        require(campaign.raisedAmount > 0, \"No funds to release\");\r\n        require(!campaign.fundsReleased, \"Funds already released\");\r\n        require(block.timestamp > campaign.endTime, \"Campaign not ended yet\");\r\n\r\n        campaign.fundsReleased = true;\r\n        campaign.isActive = false;\r\n\r\n        // Transfer raised tokens to beneficiary\r\n        require(\r\n            token.transfer(campaign.beneficiary, campaign.raisedAmount),\r\n            \"Token transfer to beneficiary failed\"\r\n        );\r\n\r\n        emit FundsReleased(_campaignId, campaign.beneficiary, campaign.raisedAmount);\r\n    }\r\n\r\n    /**\r\n     * @dev Extend campaign duration (only creator)\r\n     */\r\n    function extendCampaign(uint256 _campaignId, uint256 _additionalDays) \r\n        external \r\n        campaignExists(_campaignId)\r\n        onlyCampaignCreator(_campaignId)\r\n    {\r\n        Campaign storage campaign = campaigns[_campaignId];\r\n        require(_additionalDays > 0 && _additionalDays <= 30, \"Can extend by 1-30 days\");\r\n        \r\n        campaign.endTime += (_additionalDays * 1 days);\r\n        \r\n        emit CampaignExtended(_campaignId, campaign.endTime);\r\n    }\r\n\r\n    /**\r\n     * @dev Toggle campaign active status (creator or owner)\r\n     */\r\n    function toggleCampaignStatus(uint256 _campaignId) \r\n        external \r\n        campaignExists(_campaignId) \r\n    {\r\n        Campaign storage campaign = campaigns[_campaignId];\r\n        \r\n        require(\r\n            msg.sender == campaign.creator || msg.sender == owner,\r\n            \"Not authorized\"\r\n        );\r\n        \r\n        campaign.isActive = !campaign.isActive;\r\n        emit CampaignStatusChanged(_campaignId, campaign.isActive);\r\n    }\r\n\r\n    /**\r\n     * @dev Emergency withdraw donations if campaign fails (only owner)\r\n     */\r\n    function emergencyWithdraw(uint256 _campaignId) external onlyOwner {\r\n        Campaign storage campaign = campaigns[_campaignId];\r\n        \r\n        require(campaign.raisedAmount > 0, \"No funds to withdraw\");\r\n        require(!campaign.fundsReleased, \"Funds already released\");\r\n        \r\n        campaign.fundsReleased = true;\r\n        campaign.isActive = false;\r\n\r\n        // Return funds to owner for safekeeping (could implement refund logic later)\r\n        require(\r\n            token.transfer(owner, campaign.raisedAmount),\r\n            \"Token transfer failed\"\r\n        );\r\n    }\r\n\r\n    // ============ VIEW FUNCTIONS ============\r\n\r\n    function getCampaign(uint256 _campaignId) \r\n        external \r\n        view \r\n        campaignExists(_campaignId) \r\n        returns (Campaign memory) \r\n    {\r\n        return campaigns[_campaignId];\r\n    }\r\n\r\n    function getCampaignDonations(uint256 _campaignId) \r\n        external \r\n        view \r\n        campaignExists(_campaignId) \r\n        returns (Donation[] memory) \r\n    {\r\n        return campaignDonations[_campaignId];\r\n    }\r\n\r\n    function getCampaignDonors(uint256 _campaignId) \r\n        external \r\n        view \r\n        campaignExists(_campaignId) \r\n        returns (address[] memory) \r\n    {\r\n        return campaignDonors[_campaignId];\r\n    }\r\n\r\n    function getDonorContribution(uint256 _campaignId, address _donor) \r\n        external \r\n        view \r\n        campaignExists(_campaignId) \r\n        returns (uint256) \r\n    {\r\n        return donorContributions[_campaignId][_donor];\r\n    }\r\n\r\n    function getCampaignCount() external view returns (uint256) {\r\n        return campaignCounter;\r\n    }\r\n\r\n    function isCampaignActive(uint256 _campaignId) external view returns (bool) {\r\n        Campaign memory campaign = campaigns[_campaignId];\r\n        return campaign.isActive && block.timestamp <= campaign.endTime && !campaign.fundsReleased;\r\n    }\r\n\r\n    function getCampaignProgress(uint256 _campaignId) \r\n        external \r\n        view \r\n        campaignExists(_campaignId) \r\n        returns (uint256 percentage) \r\n    {\r\n        Campaign memory campaign = campaigns[_campaignId];\r\n        if (campaign.targetAmount == 0) return 0;\r\n        \r\n        percentage = (campaign.raisedAmount * 100) / campaign.targetAmount;\r\n        if (percentage > 100) percentage = 100;\r\n    }\r\n\r\n    function getPlatformStats() external view returns (\r\n        uint256 totalCampaigns,\r\n        uint256 totalRaised,\r\n        uint256 activeCampaigns\r\n    ) {\r\n        totalCampaigns = campaignCounter;\r\n        totalRaised = totalDonations;\r\n        \r\n        activeCampaigns = 0;\r\n        for (uint256 i = 1; i <= campaignCounter; i++) {\r\n            if (this.isCampaignActive(i)) {\r\n                activeCampaigns++;\r\n            }\r\n        }\r\n    }\r\n}"
      },
      "project/contracts/mockIDRX.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.30;\r\n\r\n/**\r\n * @title IDRXToken\r\n * @dev Full ERC-20 implementation dengan approval system untuk charity platform\r\n */\r\ncontract IDRXToken {\r\n    // ============ METADATA ============\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals;\r\n\r\n    // ============ STATE ============\r\n    mapping(address => uint256) private _balances;\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n    uint256 private _totalSupply;\r\n\r\n    // ============ EVENTS ============\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    // ============ CONSTRUCTOR ============\r\n    constructor() {\r\n        name = \"Mock IDRX Token\";\r\n        symbol = \"IDRX\";\r\n        decimals = 18;\r\n        \r\n        uint256 initialSupply = 1000000 * 10**uint256(decimals);\r\n        _mint(msg.sender, initialSupply);\r\n    }\r\n\r\n    // ============ VIEW FUNCTIONS ============\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function balanceOf(address account) public view returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    // ============ TRANSFER FUNCTIONS ============\r\n    function transfer(address to, uint256 value) public returns (bool) {\r\n        _transfer(msg.sender, to, value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\r\n        _spendAllowance(from, msg.sender, value);\r\n        _transfer(from, to, value);\r\n        return true;\r\n    }\r\n\r\n    // ============ APPROVAL FUNCTIONS ============\r\n    function approve(address spender, uint256 value) public returns (bool) {\r\n        _approve(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n        _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n        uint256 currentAllowance = _allowances[msg.sender][spender];\r\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\r\n        unchecked {\r\n            _approve(msg.sender, spender, currentAllowance - subtractedValue);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    // ============ INTERNAL FUNCTIONS ============\r\n    function _transfer(address from, address to, uint256 value) internal {\r\n        require(from != address(0), \"ERC20: transfer from the zero address\");\r\n        require(to != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        uint256 fromBalance = _balances[from];\r\n        require(fromBalance >= value, \"ERC20: transfer amount exceeds balance\");\r\n        \r\n        unchecked {\r\n            _balances[from] = fromBalance - value;\r\n            _balances[to] += value;\r\n        }\r\n\r\n        emit Transfer(from, to, value);\r\n    }\r\n\r\n    function _mint(address account, uint256 value) internal {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _totalSupply += value;\r\n        unchecked {\r\n            _balances[account] += value;\r\n        }\r\n        emit Transfer(address(0), account, value);\r\n    }\r\n\r\n    function _approve(address owner, address spender, uint256 value) internal {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = value;\r\n        emit Approval(owner, spender, value);\r\n    }\r\n\r\n    function _spendAllowance(address owner, address spender, uint256 value) internal {\r\n        uint256 currentAllowance = _allowances[owner][spender];\r\n        if (currentAllowance != type(uint256).max) {\r\n            require(currentAllowance >= value, \"ERC20: insufficient allowance\");\r\n            unchecked {\r\n                _approve(owner, spender, currentAllowance - value);\r\n            }\r\n        }\r\n    }\r\n\r\n    // ============ ADDITIONAL FEATURES FOR CHARITY ============\r\n    \r\n    /**\r\n     * @dev Mint new tokens - only for testing/development\r\n     * In production, you might want to restrict this to owner\r\n     */\r\n    function mint(address to, uint256 value) external {\r\n        // In production, add access control:\r\n        // require(msg.sender == owner, \"Only owner can mint\");\r\n        _mint(to, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Batch transfer for airdrops or bulk donations\r\n     */\r\n    function batchTransfer(address[] calldata recipients, uint256[] calldata values) external returns (bool) {\r\n        require(recipients.length == values.length, \"IDRX: arrays length mismatch\");\r\n        \r\n        for (uint256 i = 0; i < recipients.length; i++) {\r\n            _transfer(msg.sender, recipients[i], values[i]);\r\n        }\r\n        return true;\r\n    }\r\n}"
      }
    }
  }
}